clear all, close all,
%%
experiment_name = 'P-4-joint';
result_directory = '~/actuated_pendulum/results_local/';

% model_names = {'tanh','dzn','dznGen'};
model_names = {'tanh'};
results = cell(length(model_names));
for model_idx =1:length(model_names)
    model_name = model_names{model_idx};
    fprintf('---%s---\n', model_name)

    result_folder_name = sprintf('%s-%s', experiment_name, model_name);
    parameter_file_name = sprintf('model_params-%s.mat', model_name);
    test_file_name = '/Users/jack/actuated_pendulum/data/nonlinear-initial_state-0_M-500_T-10/processed/test/0198_simulation_T_10.csv';
%     test_file_name = '/Users/jack/actuated_pendulum/data/ood-initial_state_0-s_4_M-100_T-10/processed/test/0058_simulation_T_10.csv';
    experiment_config_file_name = sprintf('config-experiment-%s.json', model_name);
    model_config_file_name = sprintf('config-model-%s.json', model_name);
    model_cfg = jsondecode(fileread(fullfile(result_directory,result_folder_name,model_config_file_name)));
    experiment_cfg =jsondecode(fileread(fullfile(result_directory,result_folder_name,experiment_config_file_name)));
    normalization = jsondecode(fileread(fullfile(result_directory,result_folder_name,'normalization.json')));
    validation_log_file = fullfile(result_directory,result_folder_name,'validation.log');

    h = experiment_cfg.horizons.testing;dt = experiment_cfg.dt; w=experiment_cfg.window;
    tab = readtable(test_file_name);
    d = tab.(experiment_cfg.input_names{:});nd =length(experiment_cfg.input_names);
    d = d(w+1:w+h,:);
    d_n = (d-normalization.input_mean)./normalization.input_std;
    e = tab.(experiment_cfg.output_names{:});ne = length(experiment_cfg.output_names);
    e = e(w+1:w+h,:);
    t = linspace(0, (h-1)*dt, h);

    a=0;b=1;   

    load(fullfile(result_directory,result_folder_name, parameter_file_name))

    if exist('H', 'var')
        b_gen=true;
    else
        b_gen=false;
    end

    %% load controller parameters
    nx = size(A_tilde,1); nw = size(B2_tilde,1); nz = nw;
    fprintf('Multiplier type: %s\n', model_cfg.multiplier)
    switch model_cfg.multiplier
        case 'none'
            L = eye(nw);
        case 'diag'
            L = diag(L);
    end
    
    P_r = [-eye(nw) b*eye(nw); eye(nw) -a*eye(nw)];
    P = P_r' * [zeros(nw,nw), L'; L, zeros(nw,nw)] * P_r;

    M11_orig = [-X, C2_tilde';C2_tilde, -2*L ];
    M21_orig = [A_tilde, B2_tilde];
    M_orig = [M11_orig, M21_orig';M21_orig, -X];
    fprintf('max real eig M_orig: %f\n',max(real(eig(M_orig))))

    X_inv = X^(-1);
    A = X_inv * A_tilde;
    B2 = X_inv * B2_tilde;

    C2 = L^(-1) * C2_tilde;

    %% analyze stability
    L1 = [eye(nx),zeros(nx,nd), zeros(nx,nw);
        A, B, B2];
    L2 = [zeros(nd, nx), eye(ne), zeros(nd, nw);
        C, D, D12];

    if b_gen
        L3 = [zeros(nw,nx), zeros(nw,nd), eye(nw);
            C2-H, D21, zeros(nz,nw)];
    else
        L3 = [zeros(nw,nx),zeros(nw,nd) eye(nw);
            C2, D21, zeros(nz,nw)];
    end

    M = @(ga) L1' * [-X, zeros(nx,nx);zeros(nx,nx), X] * L1 + ...
        L2' * [-ga^2*eye(nd), zeros(nd,ne); zeros(ne,nd), eye(ne)] * L2 + ...
        L3' * P * L3;

    gas = logspace(0,6,100);
    max_real_eig = zeros(length(gas), 1);
    for idx = 1:length(gas)
        max_real_eig(idx,1) = max(real(eig(M(gas(idx)))));
    end
    fprintf('max real eig M: %f\n',min(max_real_eig))

    figure(), semilogx(gas, max_real_eig), grid on
    
    if b_gen
        fprintf('max real eig (H^T H - X): %f\n',max(real(eig(H'*H-X))))
    end
    %% analyze l2
    % sector bounds 
    eps=1e-5;

    X = sdpvar(nx,nx);
    lambda = sdpvar(nw,1);
    ga2 = sdpvar(1,1);
    
    L1 = [eye(nx),zeros(nx,nd), zeros(nx,nw);
        A, B, B2];
    L2 = [zeros(nd,nx), eye(nd), zeros(nd,nw);
        C, D, D12];

    if b_gen
        L3 = [zeros(nw,nx), zeros(nw,nd), eye(nw);
            C2-H, D21, zeros(nz,nw)];
        add_constr = ([-X, H';H, -eye(nx)]<= -eps*eye(2*nx));
    else
        L3 = [zeros(nw,nx),zeros(nw,nd) eye(nw);
            C2, D21, zeros(nz,nw)];
        add_constr = [];
    end

    P_r = [-eye(nw) b*eye(nw); eye(nw) -a*eye(nw)];
    L = diag(lambda); % can be replaced by diag multiplier
    P = P_r' * [zeros(nw,nw), L'; L, zeros(nw,nw)] * P_r;

    lmis = [];
    lmi = L1' * [-X, zeros(nx,nx); zeros(nx,nx), X] * L1 + ...
        L2' * [-ga2*eye(nd), zeros(nd,ne); zeros(ne,nd), eye(ne)] * L2 + ...
        L3' * P * L3;

    lmis = lmis + (lmi <= -eps * eye(size(L1,2)));
    lmis = lmis + (X >= eps*eye(nx));
    lmis = lmis + add_constr;
     
    sol = optimize(lmis, [], sdpsettings('solver','MOSEK','verbose', 0));
    if sol.problem == 0
        fprintf('parameters have optimal gamma: %g \n', sqrt(double(ga2)))
    else
        fprintf('Trained parameters are not feasible: %s \n', sol.info)
    end

    % write l2 gain to validation log
    fid = fopen(validation_log_file,'a+');
    fprintf(fid,'l2 gain: %f\n',sqrt(double(ga2)));
    fclose(fid);

            

    %% simulate
    x = zeros(h+1,nx);w = zeros(h,nw);e_hat_n = zeros(h,ne);z =zeros(h,nz);
    x(1,:) = zeros(1,nx); % initial condition
    for k=1:h
        z(k,:) = C2 * x(k,:)' + D21 * d_n(k,:)';
        w(k,:) = dzn(z(k,:));
        x(k+1,:) = A * x(k,:)' + B * d_n(k,:)' + B2 * w(k,:)';
        e_hat_n(k,:)= C * x(k,:)' + D * d_n(k,:)' + D12 * w(k,:)';
    end
    e_hat = e_hat_n .* normalization.output_std + normalization.output_mean;
    results{model_idx} = e_hat;

end
figure(), grid on, hold on
for i =1:length(results)
    plot(t,results{i}')
end
plot(t,e', '--')
plot(t,d', '--')
legend([model_names, 'e', 'd'])





